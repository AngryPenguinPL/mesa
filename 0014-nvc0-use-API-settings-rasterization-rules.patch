From b6a4247702668e339b0871218429bf3ec032eecd Mon Sep 17 00:00:00 2001
From: Christoph Bumiller <e0425955@student.tuwien.ac.at>
Date: Wed, 27 Aug 2014 01:39:57 +0200
Subject: [PATCH 14/34] nvc0: use API settings / rasterization rules

Implement D3D9 infrastructure inside NVC0.

Signed-off-by: David Heidelberger <david.heidelberger@ixit.cz>
---
 .../drivers/nouveau/codegen/nv50_ir_driver.h       |   5 +-
 .../drivers/nouveau/codegen/nv50_ir_from_tgsi.cpp  |  22 ++-
 .../nouveau/codegen/nv50_ir_lowering_nv50.cpp      |   2 +-
 .../nouveau/codegen/nv50_ir_lowering_nvc0.cpp      |  33 ++++-
 .../nouveau/codegen/nv50_ir_lowering_nvc0.h        |   1 +
 src/gallium/drivers/nouveau/nouveau_compiler.c     |   4 +-
 src/gallium/drivers/nouveau/nv50/nv50_program.c    |   4 +-
 src/gallium/drivers/nouveau/nv50/nv50_state.c      |   7 +-
 .../drivers/nouveau/nv50/nv50_state_validate.c     |  18 ++-
 src/gallium/drivers/nouveau/nvc0/nvc0_3d.xml.h     |   4 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_context.c    |   2 +
 src/gallium/drivers/nouveau/nvc0/nvc0_context.h    |   2 +
 src/gallium/drivers/nouveau/nvc0/nvc0_program.c    |  19 +--
 src/gallium/drivers/nouveau/nvc0/nvc0_program.h    |   1 +
 src/gallium/drivers/nouveau/nvc0/nvc0_screen.c     |  15 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c      |   5 +
 .../drivers/nouveau/nvc0/nvc0_state_validate.c     | 164 ++++++++++++++++++---
 src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h   |   1 +
 src/gallium/drivers/nouveau/nvc0/nvc0_surface.c    |   9 ++
 19 files changed, 263 insertions(+), 55 deletions(-)

diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_driver.h b/src/gallium/drivers/nouveau/codegen/nv50_ir_driver.h
index dba56bf..4e8dd34 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_driver.h
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_driver.h
@@ -155,6 +155,7 @@ struct nv50_ir_prog_info
          boolean earlyFragTests;
          boolean separateFragData;
          boolean usesDiscard;
+         uint8_t fragCoordMode; /* 0x1: integer, 0x2: upper left */
       } fp;
       struct {
          uint32_t inputOffset; /* base address for user args */
@@ -170,8 +171,9 @@ struct nv50_ir_prog_info
       uint8_t clipDistanceMask;  /* mask of clip distances defined */
       uint8_t cullDistanceMask;  /* clip distance mode (1 bit per output) */
       int8_t genUserClip;        /* request user clip planes for ClipVertex */
+      uint8_t auxCBSlot;         /* constant buffer index of aux data */
       uint16_t ucpBase;          /* base address for UCPs */
-      uint8_t ucpCBSlot;         /* constant buffer index of UCP data */
+      uint16_t fCoordAdjBase;    /* base address for FragCoord adjustment */
       uint8_t pointSize;         /* output index for PointSize */
       uint8_t instanceId;        /* system value index of InstanceID */
       uint8_t vertexId;          /* system value index of VertexID */
@@ -189,7 +191,6 @@ struct nv50_ir_prog_info
       uint16_t texBindBase;      /* base address for tex handles (nve4) */
       uint16_t suInfoBase;       /* base address for surface info (nve4) */
       uint16_t sampleInfoBase;   /* base address for sample positions */
-      uint8_t msInfoCBSlot;      /* cX[] used for multisample info */
       uint16_t msInfoBase;       /* base address for multisample info */
    } io;
 
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_from_tgsi.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_from_tgsi.cpp
index 41b91e8..230938b 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_from_tgsi.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_from_tgsi.cpp
@@ -787,6 +787,7 @@ bool Source::scanSource()
    if (info->type == PIPE_SHADER_FRAGMENT) {
       info->prop.fp.writesDepth = scan.writes_z;
       info->prop.fp.usesDiscard = scan.uses_kill;
+      info->prop.fp.fragCoordMode = 0x2; // default value
    } else
    if (info->type == PIPE_SHADER_GEOMETRY) {
       info->prop.gp.instanceCount = 1; // default value
@@ -861,8 +862,22 @@ void Source::scanProperty(const struct tgsi_full_property *prop)
       info->prop.fp.separateFragData = TRUE;
       break;
    case TGSI_PROPERTY_FS_COORD_ORIGIN:
+      switch (prop->u[0].Data) {
+          case TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
+	      info->prop.fp.fragCoordMode |=  (1 << 1);
+	      break;
+	  case TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
+	      break;
+	  default:
+	      info->prop.fp.fragCoordMode &= ~(1 << 1);
+	      break;
+      }
+      break;
    case TGSI_PROPERTY_FS_COORD_PIXEL_CENTER:
-      // we don't care
+      if (prop->u[0].Data == TGSI_FS_COORD_PIXEL_CENTER_INTEGER)
+         info->prop.fp.fragCoordMode |=  (1 << 0);
+      else
+         info->prop.fp.fragCoordMode &= ~(1 << 0);
       break;
    case TGSI_PROPERTY_VS_PROHIBIT_UCPS:
       info->io.genUserClip = -1;
@@ -1474,6 +1489,9 @@ Converter::fetchSrc(tgsi::Instruction::SrcRegister src, int c, Value *ptr)
             return loadImm(NULL, swz == TGSI_SWIZZLE_W ? 1.0f : 0.0f);
 	 if (!ptr && info->in[idx].sn == TGSI_SEMANTIC_FACE)
             return mkOp1v(OP_RDSV, TYPE_F32, getSSA(), mkSysVal(SV_FACE, 0));
+         if (!ptr && info->in[idx].sn == TGSI_SEMANTIC_POSITION)
+            return mkOp1v(OP_RDSV, TYPE_F32, getSSA(), mkSysVal(SV_POSITION,
+                                                                swz));
          return interpolate(src, c, shiftAddress(ptr));
       } else
       if (prog->getType() == Program::TYPE_GEOMETRY) {
@@ -2913,7 +2931,7 @@ Converter::handleUserClipPlanes()
 
    for (c = 0; c < 4; ++c) {
       for (i = 0; i < info->io.genUserClip; ++i) {
-         Symbol *sym = mkSymbol(FILE_MEMORY_CONST, info->io.ucpCBSlot,
+         Symbol *sym = mkSymbol(FILE_MEMORY_CONST, info->io.auxCBSlot,
                                 TYPE_F32, info->io.ucpBase + i * 16 + c * 4);
          Value *ucp = mkLoadv(TYPE_F32, sym, NULL);
          if (c == 0)
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nv50.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nv50.cpp
index e283424..86012a6 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nv50.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nv50.cpp
@@ -674,7 +674,7 @@ void NV50LoweringPreSSA::loadTexMsInfo(uint32_t off, Value **ms,
 
 void NV50LoweringPreSSA::loadMsInfo(Value *ms, Value *s, Value **dx, Value **dy) {
    // Given a MS level, and a sample id, compute the delta x/y
-   uint8_t b = prog->driver->io.msInfoCBSlot;
+   uint8_t b = prog->driver->io.auxCBSlot;
    Value *off = new_LValue(func, FILE_ADDRESS), *t = new_LValue(func, FILE_GPR);
 
    // The required information is at mslevel * 16 * 4 + sample * 8
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
index 9c06d04..c3c0eb2 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
@@ -1019,12 +1019,21 @@ NVC0LoweringPass::loadResInfo32(Value *ptr, uint32_t off)
 inline Value *
 NVC0LoweringPass::loadMsInfo32(Value *ptr, uint32_t off)
 {
-   uint8_t b = prog->driver->io.msInfoCBSlot;
+   uint8_t b = prog->driver->io.auxCBSlot;
    off += prog->driver->io.msInfoBase;
    return bld.
       mkLoadv(TYPE_U32, bld.mkSymbol(FILE_MEMORY_CONST, b, TYPE_U32, off), ptr);
 }
 
+inline Value *
+NVC0LoweringPass::loadFCoordAdj32(uint32_t p)
+{
+   uint8_t b = prog->driver->io.auxCBSlot;
+   p += prog->driver->io.fCoordAdjBase;
+   return bld.
+      mkLoadv(TYPE_U32, bld.mkSymbol(FILE_MEMORY_CONST, b, TYPE_U32, p), NULL);
+}
+
 /* On nvc0, surface info is obtained via the surface binding points passed
  * to the SULD/SUST instructions.
  * On nve4, surface info is stored in c[] and is used by various special
@@ -1422,13 +1431,14 @@ NVC0LoweringPass::handleRDSV(Instruction *i)
 {
    Symbol *sym = i->getSrc(0)->asSym();
    const SVSemantic sv = sym->reg.data.sv.sv;
+   const int svIndex = sym->reg.data.sv.index;
    Value *vtx = NULL;
    Instruction *ld;
    uint32_t addr = targ->getSVAddress(FILE_SHADER_INPUT, sym);
 
    if (addr >= 0x400) {
       // mov $sreg
-      if (sym->reg.data.sv.index == 3) {
+      if (svIndex == 3) {
          // TGSI backend may use 4th component of TID,NTID,CTAID,NCTAID
          i->op = OP_MOV;
          i->setSrc(0, bld.mkImm((sv == SV_NTID || sv == SV_NCTAID) ? 1 : 0));
@@ -1438,15 +1448,26 @@ NVC0LoweringPass::handleRDSV(Instruction *i)
 
    switch (sv) {
    case SV_POSITION:
+   {
       assert(prog->getType() == Program::TYPE_FRAGMENT);
+      LValue *dst = i->getDef(0)->asLValue();
+
       if (i->srcExists(1)) {
          // Pass offset through to the interpolation logic
          ld = bld.mkInterp(NV50_IR_INTERP_LINEAR | NV50_IR_INTERP_OFFSET,
-                           i->getDef(0), addr, NULL);
+                           dst, addr, NULL);
          ld->setSrc(1, i->getSrc(1));
       } else {
-         bld.mkInterp(NV50_IR_INTERP_LINEAR, i->getDef(0), addr, NULL);
+         bld.mkInterp(NV50_IR_INTERP_LINEAR, dst, addr, NULL);
       }
+
+      if (svIndex == 0) {
+         bld.mkOp2(OP_ADD, TYPE_F32, dst, dst, loadFCoordAdj32(0x8));
+      } else if (svIndex == 1) {
+         Value *t = loadFCoordAdj32(0x4);
+         bld.mkOp3(OP_MAD, TYPE_F32, dst, dst, loadFCoordAdj32(0x0), t);
+      }
+   }
       break;
    case SV_FACE:
    {
@@ -1460,13 +1481,13 @@ NVC0LoweringPass::handleRDSV(Instruction *i)
       break;
    case SV_TESS_COORD:
       assert(prog->getType() == Program::TYPE_TESSELLATION_EVAL);
-      readTessCoord(i->getDef(0)->asLValue(), i->getSrc(0)->reg.data.sv.index);
+      readTessCoord(i->getDef(0)->asLValue(), svIndex);
       break;
    case SV_NTID:
    case SV_NCTAID:
    case SV_GRIDID:
       assert(targ->getChipset() >= NVISA_GK104_CHIPSET); // mov $sreg otherwise
-      if (sym->reg.data.sv.index == 3) {
+      if (svIndex == 3) {
          i->op = OP_MOV;
          i->setSrc(0, bld.mkImm(sv == SV_GRIDID ? 0 : 1));
          return true;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.h b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.h
index d8ff5cd..5d5f7e8 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.h
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.h
@@ -119,6 +119,7 @@ private:
 
    Value *loadResInfo32(Value *ptr, uint32_t off);
    Value *loadMsInfo32(Value *ptr, uint32_t off);
+   Value *loadFCoordAdj32(uint32_t off);
    Value *loadTexHandle(Value *ptr, unsigned int slot);
 
    void adjustCoordinatesMS(TexInstruction *);
diff --git a/src/gallium/drivers/nouveau/nouveau_compiler.c b/src/gallium/drivers/nouveau/nouveau_compiler.c
index 8660498..fab3b36 100644
--- a/src/gallium/drivers/nouveau/nouveau_compiler.c
+++ b/src/gallium/drivers/nouveau/nouveau_compiler.c
@@ -112,12 +112,12 @@ nouveau_codegen(int chipset, int type, struct tgsi_token tokens[],
    info.bin.sourceRep = NV50_PROGRAM_IR_TGSI;
    info.bin.source = tokens;
 
-   info.io.ucpCBSlot = 15;
+   info.io.auxCBSlot = 15;
    info.io.ucpBase = NV50_CB_AUX_UCP_OFFSET;
 
    info.io.resInfoCBSlot = 15;
    info.io.suInfoBase = NV50_CB_AUX_TEX_MS_OFFSET;
-   info.io.msInfoCBSlot = 15;
+   info.io.auxCBSlot = 15;
    info.io.msInfoBase = NV50_CB_AUX_MS_OFFSET;
 
    info.assignSlots = dummy_assign_slots;
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_program.c b/src/gallium/drivers/nouveau/nv50/nv50_program.c
index 4744a3c..fead2e7 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_program.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_program.c
@@ -332,7 +332,7 @@ nv50_program_translate(struct nv50_program *prog, uint16_t chipset)
    info->bin.sourceRep = NV50_PROGRAM_IR_TGSI;
    info->bin.source = (void *)prog->pipe.tokens;
 
-   info->io.ucpCBSlot = 15;
+   info->io.auxCBSlot = 15;
    info->io.ucpBase = NV50_CB_AUX_UCP_OFFSET;
    info->io.genUserClip = prog->vp.clpd_nr;
    info->io.sampleInterp = prog->fp.sample_interp;
@@ -340,7 +340,7 @@ nv50_program_translate(struct nv50_program *prog, uint16_t chipset)
    info->io.resInfoCBSlot = 15;
    info->io.suInfoBase = NV50_CB_AUX_TEX_MS_OFFSET;
    info->io.sampleInfoBase = NV50_CB_AUX_SAMPLE_OFFSET;
-   info->io.msInfoCBSlot = 15;
+   info->io.auxCBSlot = 15;
    info->io.msInfoBase = NV50_CB_AUX_MS_OFFSET;
 
    info->assignSlots = nv50_program_assign_varying_slots;
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index cf84f88..946e752 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -53,14 +53,13 @@
  *     good.)
  *
  *  ! pipe_rasterizer_state.line_last_pixel is ignored - it is never drawn
+ *    (There does not seem to be a hardware switch for this.
+ *     Note that the pixel center setting affects line rasterization if the
+ *     vertex coordinates are not adjusted to compensate.)
  *
  *  ! pipe_rasterizer_state.flatshade_first also applies to QUADS
  *    (There's a GL query for that, forcing an exception is just ridiculous.)
  *
- *  ! pipe_rasterizer_state.half_pixel_center is ignored - pixel centers
- *     are always at half integer coordinates and the top-left rule applies
- *    (There does not seem to be a hardware switch for this.)
- *
  *  ! pipe_rasterizer_state.sprite_coord_enable is masked with 0xff on NVC0
  *    (The hardware only has 8 slots meant for TexCoord and we have to assign
  *     in advance to maintain elegant separate shader objects.)
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c b/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
index 6916bea..4cdaa9a 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
@@ -24,6 +24,22 @@ nv50_validate_fb(struct nv50_context *nv50)
    unsigned ms_mode = NV50_3D_MULTISAMPLE_MODE_MS1;
    uint32_t array_size = 0xffff, array_mode = 0;
 
+   if (nv50->framebuffer.nr_cbufs == 0) {
+      /* XXX: Does RT_CONTROL affect speed of z-only rendering ?
+       * Set it to 0 when we can to be safe.
+       */
+      BEGIN_NV04(push, NV50_3D(RT_CONTROL), 1);
+      if (nv50->zsa->pipe.alpha.enabled) {
+         /* need at least 1 RT to make alpha test work */
+         PUSH_DATA (push, 1);
+         nv50_fb_set_null_rt(push, 0);
+      } else {
+         PUSH_DATA (push, 0);
+      }
+   }
+   if (!(nv50->dirty & NV50_NEW_FRAMEBUFFER))
+      return; /* only ZSA changed */
+
    nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_FB);
 
    BEGIN_NV04(push, NV50_3D(RT_CONTROL), 1);
@@ -429,7 +445,7 @@ static struct state_validate {
     void (*func)(struct nv50_context *);
     uint32_t states;
 } validate_list[] = {
-    { nv50_validate_fb,            NV50_NEW_FRAMEBUFFER },
+    { nv50_validate_fb,            NV50_NEW_FRAMEBUFFER | NV50_NEW_ZSA },
     { nv50_validate_blend,         NV50_NEW_BLEND },
     { nv50_validate_zsa,           NV50_NEW_ZSA },
     { nv50_validate_sample_mask,   NV50_NEW_SAMPLE_MASK },
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_3d.xml.h b/src/gallium/drivers/nouveau/nvc0/nvc0_3d.xml.h
index 94b447b..311051b 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_3d.xml.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_3d.xml.h
@@ -318,6 +318,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define NVC0_3D_VERTEX_BUFFER_COUNT				0x00000d78
 
+#define NVC0_3D_DEPTH_CLIP_NEGATIVE_Z				0x00000d7c
+
 #define NVC0_3D_CLEAR_COLOR(i0)				       (0x00000d80 + 0x4*(i0))
 #define NVC0_3D_CLEAR_COLOR__ESIZE				0x00000004
 #define NVC0_3D_CLEAR_COLOR__LEN				0x00000004
@@ -1039,7 +1041,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define NVC0_3D_CULL_FACE_BACK					0x00000405
 #define NVC0_3D_CULL_FACE_FRONT_AND_BACK			0x00000408
 
-#define NVC0_3D_LINE_LAST_PIXEL					0x00001924
+#define NVC0_3D_PIXEL_CENTER_INTEGER				0x00001924
 
 #define NVC0_3D_VIEWPORT_TRANSFORM_EN				0x0000192c
 
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_context.c b/src/gallium/drivers/nouveau/nvc0/nvc0_context.c
index b33a673..af41f42 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_context.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_context.c
@@ -320,6 +320,8 @@ nvc0_create(struct pipe_screen *pscreen, void *priv)
    /* shader builtin library is per-screen, but we need a context for m2mf */
    nvc0_program_library_upload(nvc0);
 
+   nvc0->state.rasterizer_api = 0x2; /* upper left origin */
+
    /* add permanently resident buffers to bufctxts */
 
    flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
index 63e73ae..c30094f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
@@ -113,6 +113,7 @@ struct nvc0_context {
    uint32_t dirty_cp; /* dirty flags for compute state */
 
    struct {
+      uint8_t rasterizer_api; /* rasterizer OGL/D3D bits */
       boolean flushed;
       boolean rasterizer_discard;
       boolean early_z_forced;
@@ -182,6 +183,7 @@ struct nvc0_context {
    unsigned viewports_dirty;
    struct pipe_clip_state clip;
 
+
    unsigned sample_mask;
    unsigned min_samples;
 
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_program.c b/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
index 21be8b7..bcfaf04 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
@@ -463,6 +463,7 @@ nvc0_fp_gen_header(struct nvc0_program *fp, struct nv50_ir_prog_info *info)
    }
 
    fp->fp.early_z = info->prop.fp.earlyFragTests;
+   fp->fp.frag_coord_mode = info->prop.fp.fragCoordMode;
 
    return 0;
 }
@@ -538,29 +539,29 @@ nvc0_program_translate(struct nvc0_program *prog, uint16_t chipset)
    info->bin.sourceRep = NV50_PROGRAM_IR_TGSI;
    info->bin.source = (void *)prog->pipe.tokens;
 
-   info->io.genUserClip = prog->vp.num_ucps;
-   info->io.ucpBase = 256;
-   info->io.ucpCBSlot = 15;
    info->io.sampleInterp = prog->fp.sample_interp;
 
    if (prog->type == PIPE_SHADER_COMPUTE) {
+      info->io.auxCBSlot = 0;
+      info->io.msInfoBase = NVE4_CP_INPUT_MS_OFFSETS;
       if (chipset >= NVISA_GK104_CHIPSET) {
          info->io.resInfoCBSlot = 0;
          info->io.texBindBase = NVE4_CP_INPUT_TEX(0);
          info->io.suInfoBase = NVE4_CP_INPUT_SUF(0);
          info->prop.cp.gridInfoBase = NVE4_CP_INPUT_GRID_INFO(0);
       }
-      info->io.msInfoCBSlot = 0;
-      info->io.msInfoBase = NVE4_CP_INPUT_MS_OFFSETS;
    } else {
+      info->io.auxCBSlot = NVC0_CB_AUX_SLOT;
+      info->io.genUserClip = prog->vp.num_ucps;
+      info->io.ucpBase = NVC0_CB_AUX_UCP_OFFSET;
+      info->io.fCoordAdjBase = NVC0_CB_AUX_FCOORD_ADJ_OFFSET;
+      info->io.msInfoBase = NVC0_CB_AUX_MS_INFO_OFFSET; /* TODO */
       if (chipset >= NVISA_GK104_CHIPSET) {
-         info->io.texBindBase = 0x20;
-         info->io.suInfoBase = 0; /* TODO */
+         info->io.texBindBase = NVE4_CB_AUX_TEX_BIND_OFFSET;
+         info->io.suInfoBase = NVE4_CB_AUX_SU_INFO_OFFSET; /* TODO */
       }
       info->io.resInfoCBSlot = 15;
       info->io.sampleInfoBase = 256 + 128;
-      info->io.msInfoCBSlot = 15;
-      info->io.msInfoBase = 0; /* TODO */
    }
 
    info->assignSlots = nvc0_program_assign_varying_slots;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_program.h b/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
index 3fd9d21..8a1b45f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
@@ -45,6 +45,7 @@ struct nvc0_program {
    } vp;
    struct {
       uint8_t early_z;
+      uint8_t frag_coord_mode; /* 0x1: integer, 0x2: upper left */
       uint8_t in_pos[PIPE_MAX_SHADER_INPUTS];
       uint8_t sample_interp;
    } fp;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
index fdbcc64..35ae39c 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
@@ -150,6 +150,9 @@ nvc0_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_INDEP_BLEND_FUNC:
    case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
    case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
+   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
+   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
+   case PIPE_CAP_RASTERIZER_LOWER_LEFT_ORIGIN:
    case PIPE_CAP_PRIMITIVE_RESTART:
    case PIPE_CAP_TGSI_INSTANCEID:
    case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
@@ -178,8 +181,6 @@ nvc0_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
       return (class_3d == NVE4_3D_CLASS) ? 1 : 0;
 
    /* unsupported caps */
-   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
-   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
    case PIPE_CAP_SHADER_STENCIL_EXPORT:
    case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
    case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
@@ -789,8 +790,6 @@ nvc0_screen_create(struct nouveau_device *dev)
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(LINE_WIDTH_SEPARATE), 1);
    PUSH_DATA (push, 1);
-   BEGIN_NVC0(push, NVC0_3D(LINE_LAST_PIXEL), 1);
-   PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(PRIM_RESTART_WITH_DRAW_ARRAYS), 1);
    PUSH_DATA (push, 1);
    BEGIN_NVC0(push, NVC0_3D(BLEND_SEPARATE_ALPHA), 1);
@@ -836,9 +835,9 @@ nvc0_screen_create(struct nouveau_device *dev)
       /* TIC and TSC entries for each unit (nve4+ only) */
       /* auxiliary constants (6 user clip planes, base instance id) */
       BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
-      PUSH_DATA (push, 512);
-      PUSH_DATAh(push, screen->uniform_bo->offset + (5 << 16) + (i << 9));
-      PUSH_DATA (push, screen->uniform_bo->offset + (5 << 16) + (i << 9));
+      PUSH_DATA (push, NVC0_CB_AUX_SIZE);
+      PUSH_DATAh(push, screen->uniform_bo->offset + NVC0_CB_AUX_BASE(i));
+      PUSH_DATA (push, screen->uniform_bo->offset + NVC0_CB_AUX_BASE(i));
       BEGIN_NVC0(push, NVC0_3D(CB_BIND(i)), 1);
       PUSH_DATA (push, (15 << 4) | 1);
       if (screen->eng3d->oclass >= NVE4_3D_CLASS) {
@@ -949,6 +948,8 @@ nvc0_screen_create(struct nouveau_device *dev)
    BEGIN_NVC0(push, NVC0_3D(CLEAR_FLAGS), 1);
    PUSH_DATA (push, 0);
 
+   BEGIN_NVC0(push, NVC0_3D(PIXEL_CENTER_INTEGER), 1);
+   PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_TRANSFORM_EN), 1);
    PUSH_DATA (push, 1);
    for (i = 0; i < NVC0_MAX_VIEWPORTS; i++) {
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index d1a7cf5..bda2579 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -313,6 +313,11 @@ nvc0_rasterizer_state_create(struct pipe_context *pipe,
     SB_BEGIN_3D(so, VIEW_VOLUME_CLIP_CTRL, 1);
     SB_DATA    (so, reg);
 
+    so->api =
+       (!cso->half_pixel_center << 0) |
+       (!cso->lower_left_origin << 1) |
+       (cso->clip_halfz << 2);
+
     assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
     return (void *)so;
 }
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
index dd7201b..09d1bd4 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
@@ -4,6 +4,35 @@
 #include "nvc0/nvc0_context.h"
 #include "nv50/nv50_defs.xml.h"
 
+static INLINE void
+nvc0_validate_api_settings(struct nvc0_context *nvc0)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   uint8_t m;
+   const uint8_t api = nvc0->rast->api;
+
+   m = api ^ nvc0->state.rasterizer_api;
+   if (nvc0->dirty & NVC0_NEW_FRAMEBUFFER)
+      m |= ~api & 0x2; /* only if we have to update y offset */
+
+   nvc0->state.rasterizer_api = api;
+
+   if (m & ~0x2) {
+      IMMED_NVC0(push, NVC0_3D(PIXEL_CENTER_INTEGER), !!(api & 0x1));
+      IMMED_NVC0(push, NVC0_3D(DEPTH_CLIP_NEGATIVE_Z), !!(api & 0x4));
+      /* switch point rasterization rules to D3D if settings look like D3D */
+      IMMED_NVC0(push, NVC0_3D(POINT_RASTER_RULES), !!(api & 0x4) &&
+                 nvc0->rast->pipe.point_quad_rasterization);
+   }
+   if (m & 0x2) { /* fb height or origin changed */
+      const uint8_t mode = (nvc0->rast->api & 0x2) ?
+         0 : NVC0_3D_SCREEN_Y_CONTROL_Y_NEGATE;
+      IMMED_NVC0(push, NVC0_3D(SCREEN_Y_CONTROL), mode);
+      BEGIN_NVC0(push, NVC0_3D(WINDOW_OFFSET_Y), 1);
+      PUSH_DATA (push, (nvc0->rast->api & 0x2) ? 0 : nvc0->framebuffer.height);
+   }
+}
+
 #if 0
 static void
 nvc0_validate_zcull(struct nvc0_context *nvc0)
@@ -76,14 +105,19 @@ nvc0_validate_fb(struct nvc0_context *nvc0)
     unsigned ms_mode = NVC0_3D_MULTISAMPLE_MODE_MS1;
     boolean serialize = FALSE;
 
+    nvc0_validate_api_settings(nvc0); /* depends on rasterizer */
+
+    if (!(nvc0->dirty & NVC0_NEW_FRAMEBUFFER))
+      return;
     nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_FB);
 
-    BEGIN_NVC0(push, NVC0_3D(RT_CONTROL), 1);
-    PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
     BEGIN_NVC0(push, NVC0_3D(SCREEN_SCISSOR_HORIZ), 2);
     PUSH_DATA (push, fb->width << 16);
     PUSH_DATA (push, fb->height << 16);
 
+    BEGIN_NVC0(push, NVC0_3D(RT_CONTROL), 1);
+    PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
+
     for (i = 0; i < fb->nr_cbufs; ++i) {
         struct nv50_surface *sf;
         struct nv04_resource *res;
@@ -143,6 +177,11 @@ nvc0_validate_fb(struct nvc0_context *nvc0)
         /* only register for writing, otherwise we'd always serialize here */
         BCTX_REFN(nvc0->bufctx_3d, FB, res, WR);
     }
+    if (unlikely(!fb->nr_cbufs && nvc0->zsa->pipe.alpha.enabled)) {
+       /* need RT_COUNT >= 1 to make alpha test work */
+       IMMED_NVC0(push, NVC0_3D(RT_CONTROL), 1);
+       nvc0_fb_set_null_rt(push, 0);
+    }
 
     if (fb->zsbuf) {
         struct nv50_miptree *mt = nv50_miptree(fb->zsbuf->texture);
@@ -200,7 +239,7 @@ nvc0_validate_fb(struct nvc0_context *nvc0)
     NOUVEAU_DRV_STAT(&nvc0->screen->base, gpu_serialize_count, serialize);
 }
 
-static void
+static INLINE void
 nvc0_validate_blend_colour(struct nvc0_context *nvc0)
 {
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -212,7 +251,7 @@ nvc0_validate_blend_colour(struct nvc0_context *nvc0)
    PUSH_DATAf(push, nvc0->blend_colour.color[3]);
 }
 
-static void
+static INLINE void
 nvc0_validate_stencil_ref(struct nvc0_context *nvc0)
 {
     struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -222,7 +261,7 @@ nvc0_validate_stencil_ref(struct nvc0_context *nvc0)
     IMMED_NVC0(push, NVC0_3D(STENCIL_BACK_FUNC_REF), ref[1]);
 }
 
-static void
+static INLINE void
 nvc0_validate_stipple(struct nvc0_context *nvc0)
 {
     struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -385,6 +424,52 @@ nvc0_validate_clip(struct nvc0_context *nvc0)
 }
 
 static void
+nvc0_validate_derived_aux_constants(struct nvc0_context *nvc0)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   struct nouveau_bo *bo = nvc0->screen->uniform_bo;
+   float ys, yt, xt;
+   uint8_t frag_coord_mode;
+
+   if (!nvc0->fragprog ||
+       !(nvc0->fragprog->hdr[5] & (0x3 << 28)) || /* FRAG_COORD_UMASK.xy */
+       !nvc0->rast)
+      return;
+   /* NOTE: FB Y flip probably does affect FragCoord */
+   frag_coord_mode = nvc0->rast->api & 0x3;
+
+   xt = 0.0f;
+   ys = 1.0f;
+   yt = 0.0f;
+   switch (frag_coord_mode ^ nvc0->fragprog->fp.frag_coord_mode) {
+   case 0x1: /* center shift only */
+      xt = (frag_coord_mode & 1) ? +0.5f : -0.5f;
+      yt = xt;
+      break;
+   case 0x2: /* inversion only */
+      ys = -1.0f;
+      yt = (float)nvc0->framebuffer.height - (float)(frag_coord_mode & 1);
+      break;
+   case 0x3: /* inversion and center shift */
+      xt = (frag_coord_mode & 1) ? +0.5f : -0.5f;
+      ys = -1.0f;
+      yt = (float)nvc0->framebuffer.height - 0.5f;
+      break;
+   default:
+      break;
+   }
+   BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
+   PUSH_DATA (push, NVC0_CB_AUX_SIZE);
+   PUSH_DATAh(push, bo->offset + NVC0_CB_AUX_BASE(4));
+   PUSH_DATA (push, bo->offset + NVC0_CB_AUX_BASE(4));
+   BEGIN_1IC0(push, NVC0_3D(CB_POS), 1 + 3);
+   PUSH_DATA (push, NVC0_CB_AUX_FCOORD_ADJ_OFFSET);
+   PUSH_DATAf(push, ys); /* FragCoord.y scale */
+   PUSH_DATAf(push, yt); /* FragCoord.y translate */
+   PUSH_DATAf(push, xt); /* FragCoord.x adjust */
+}
+
+static void
 nvc0_validate_blend(struct nvc0_context *nvc0)
 {
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -400,6 +485,16 @@ nvc0_validate_zsa(struct nvc0_context *nvc0)
 
    PUSH_SPACE(push, nvc0->zsa->size);
    PUSH_DATAp(push, nvc0->zsa->state, nvc0->zsa->size);
+
+   if (!(nvc0->dirty & NVC0_NEW_FRAMEBUFFER) && !nvc0->framebuffer.nr_cbufs) {
+      if (nvc0->zsa->pipe.alpha.enabled) {
+         /* need RT_COUNT >= 1 to make alpha test work */
+         IMMED_NVC0(push, NVC0_3D(RT_CONTROL), 1);
+         nvc0_fb_set_null_rt(push, 0);
+      } else {
+         IMMED_NVC0(push, NVC0_3D(RT_CONTROL), 0);
+      }
+   }
 }
 
 static void
@@ -466,7 +561,7 @@ nvc0_constbufs_validate(struct nvc0_context *nvc0)
    }
 }
 
-static void
+static INLINE void
 nvc0_validate_sample_mask(struct nvc0_context *nvc0)
 {
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -515,6 +610,16 @@ nvc0_validate_global_residents(struct nvc0_context *nvc0,
 }
 
 static void
+nvc0_validate_shaders(struct nvc0_context *nvc0)
+{
+   if (nvc0->dirty & NVC0_NEW_VERTPROG) nvc0_vertprog_validate(nvc0);
+   if (nvc0->dirty & NVC0_NEW_TCTLPROG) nvc0_tctlprog_validate(nvc0);
+   if (nvc0->dirty & NVC0_NEW_TEVLPROG) nvc0_tevlprog_validate(nvc0);
+   if (nvc0->dirty & NVC0_NEW_GMTYPROG) nvc0_gmtyprog_validate(nvc0);
+   if (nvc0->dirty & NVC0_NEW_FRAGPROG) nvc0_fragprog_validate(nvc0);
+}
+
+static void
 nvc0_validate_derived_1(struct nvc0_context *nvc0)
 {
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
@@ -533,6 +638,28 @@ nvc0_validate_derived_1(struct nvc0_context *nvc0)
       nvc0->state.rasterizer_discard = rasterizer_discard;
       IMMED_NVC0(push, NVC0_3D(RASTERIZE_ENABLE), !rasterizer_discard);
    }
+
+   if (nvc0->dirty & (NVC0_NEW_FRAMEBUFFER |
+                      NVC0_NEW_FRAGPROG |
+                      NVC0_NEW_RASTERIZER))
+      nvc0_validate_derived_aux_constants(nvc0);
+}
+
+static void
+nvc0_validate_misc_values(struct nvc0_context *nvc0)
+{
+   if (nvc0->dirty & NVC0_NEW_SAMPLE_MASK)
+      nvc0_validate_sample_mask(nvc0);
+
+   if (nvc0->dirty & NVC0_NEW_BLEND_COLOUR)
+      nvc0_validate_blend_colour(nvc0);
+
+   if (nvc0->dirty & NVC0_NEW_STENCIL_REF)
+      nvc0_validate_stencil_ref(nvc0);
+
+   /* unlikely because deprecated */
+   if (unlikely(nvc0->dirty & NVC0_NEW_STIPPLE))
+      nvc0_validate_stipple(nvc0);
 }
 
 static void
@@ -578,22 +705,23 @@ static struct state_validate {
     void (*func)(struct nvc0_context *);
     uint32_t states;
 } validate_list[] = {
-    { nvc0_validate_fb,            NVC0_NEW_FRAMEBUFFER },
-    { nvc0_validate_blend,         NVC0_NEW_BLEND },
+    { nvc0_validate_fb,            NVC0_NEW_FRAMEBUFFER | NVC0_NEW_RASTERIZER },
     { nvc0_validate_zsa,           NVC0_NEW_ZSA },
-    { nvc0_validate_sample_mask,   NVC0_NEW_SAMPLE_MASK },
+    { nvc0_validate_blend,         NVC0_NEW_BLEND },
     { nvc0_validate_rasterizer,    NVC0_NEW_RASTERIZER },
-    { nvc0_validate_blend_colour,  NVC0_NEW_BLEND_COLOUR },
-    { nvc0_validate_stencil_ref,   NVC0_NEW_STENCIL_REF },
-    { nvc0_validate_stipple,       NVC0_NEW_STIPPLE },
+    { nvc0_validate_misc_values,   NVC0_NEW_SAMPLE_MASK |
+                                   NVC0_NEW_BLEND_COLOUR |
+                                   NVC0_NEW_STENCIL_REF |
+                                   NVC0_NEW_STIPPLE },
     { nvc0_validate_scissor,       NVC0_NEW_SCISSOR | NVC0_NEW_RASTERIZER },
     { nvc0_validate_viewport,      NVC0_NEW_VIEWPORT },
-    { nvc0_vertprog_validate,      NVC0_NEW_VERTPROG },
-    { nvc0_tctlprog_validate,      NVC0_NEW_TCTLPROG },
-    { nvc0_tevlprog_validate,      NVC0_NEW_TEVLPROG },
-    { nvc0_gmtyprog_validate,      NVC0_NEW_GMTYPROG },
-    { nvc0_fragprog_validate,      NVC0_NEW_FRAGPROG },
-    { nvc0_validate_derived_1,     NVC0_NEW_FRAGPROG | NVC0_NEW_ZSA |
+    { nvc0_validate_shaders,       NVC0_NEW_VERTPROG |
+                                   NVC0_NEW_TCTLPROG |
+                                   NVC0_NEW_TEVLPROG |
+                                   NVC0_NEW_GMTYPROG |
+                                   NVC0_NEW_FRAGPROG },
+    { nvc0_validate_derived_1,     NVC0_NEW_FRAMEBUFFER |
+                                   NVC0_NEW_FRAGPROG | NVC0_NEW_ZSA |
                                    NVC0_NEW_RASTERIZER },
     { nvc0_validate_clip,          NVC0_NEW_CLIP | NVC0_NEW_RASTERIZER |
                                    NVC0_NEW_VERTPROG |
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h b/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
index 80c3342..3382933 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
@@ -22,6 +22,7 @@ struct nvc0_blend_stateobj {
 
 struct nvc0_rasterizer_stateobj {
    struct pipe_rasterizer_state pipe;
+   uint8_t api; /* some OGL/D3D switch bits from pipe, for quick comparison */
    int size;
    uint32_t state[43];
 };
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c b/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c
index 17fe66d..5dc9c8a 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c
@@ -295,6 +295,10 @@ nvc0_clear_render_target(struct pipe_context *pipe,
    PUSH_DATAf(push, color->f[2]);
    PUSH_DATAf(push, color->f[3]);
 
+   if (!(nvc0->state.rasterizer_api & 0x2)) {
+      BEGIN_NVC0(push, NVC0_3D(WINDOW_OFFSET_Y), 1);
+      PUSH_DATA (push, height);
+   }
    BEGIN_NVC0(push, NVC0_3D(SCREEN_SCISSOR_HORIZ), 2);
    PUSH_DATA (push, ( width << 16) | dstx);
    PUSH_DATA (push, (height << 16) | dsty);
@@ -518,6 +522,10 @@ nvc0_clear_depth_stencil(struct pipe_context *pipe,
 		mode |= NVC0_3D_CLEAR_BUFFERS_S;
 	}
 
+        if (!(nvc0->state.rasterizer_api & 0x2)) {
+		BEGIN_NVC0(push, NVC0_3D(WINDOW_OFFSET_Y), 1);
+		PUSH_DATA (push, height);
+	}
 	BEGIN_NVC0(push, NVC0_3D(SCREEN_SCISSOR_HORIZ), 2);
 	PUSH_DATA (push, ( width << 16) | dstx);
 	PUSH_DATA (push, (height << 16) | dsty);
@@ -1494,6 +1502,7 @@ nvc0_blitctx_create(struct nvc0_context *nvc0)
    nvc0->blit->nvc0 = nvc0;
 
    nvc0->blit->rast.pipe.half_pixel_center = 1;
+   nvc0->blit->rast.api = 0x2;
 
    return TRUE;
 }
-- 
2.1.3

