From 054ce7ade4b3087131a809c09f6f46b3fa8789d1 Mon Sep 17 00:00:00 2001
From: Christoph Bumiller <e0425955@student.tuwien.ac.at>
Date: Wed, 19 Jun 2013 13:27:55 +0200
Subject: [PATCH 29/34] nv50: record CB slot for bound constant buffers

So we don't have to re-bind every time a transfer on a bound buffer
is performed, i.e. on all constant uploads with d3d9.
---
 src/gallium/drivers/nouveau/nouveau_buffer.c       |  9 ++---
 src/gallium/drivers/nouveau/nouveau_buffer.h       |  2 +
 src/gallium/drivers/nouveau/nouveau_context.h      |  8 ++--
 src/gallium/drivers/nouveau/nv50/nv50_context.h    |  5 +--
 .../drivers/nouveau/nv50/nv50_shader_state.c       |  5 ++-
 src/gallium/drivers/nouveau/nv50/nv50_state.c      |  4 +-
 src/gallium/drivers/nouveau/nv50/nv50_transfer.c   | 37 +++++++++----------
 src/gallium/drivers/nouveau/nvc0/nvc0_context.h    |  5 +--
 .../drivers/nouveau/nvc0/nvc0_state_validate.c     | 43 +++++++++++++++++-----
 src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c   | 26 ++++++-------
 10 files changed, 83 insertions(+), 61 deletions(-)

diff --git a/src/gallium/drivers/nouveau/nouveau_buffer.c b/src/gallium/drivers/nouveau/nouveau_buffer.c
index c077a3b..926fc44 100644
--- a/src/gallium/drivers/nouveau/nouveau_buffer.c
+++ b/src/gallium/drivers/nouveau/nouveau_buffer.c
@@ -71,6 +71,8 @@ nouveau_buffer_allocate(struct nouveau_screen *screen,
 
    util_range_set_empty(&buf->valid_buffer_range);
 
+   buf->cb_slot = -1;
+
    return TRUE;
 }
 
@@ -212,7 +214,7 @@ nouveau_transfer_write(struct nouveau_context *nv, struct nouveau_transfer *tx,
                     tx->bo, tx->offset + offset, NOUVEAU_BO_GART, size);
    else
    if ((buf->base.bind & PIPE_BIND_CONSTANT_BUFFER) && nv->push_cb && can_cb)
-      nv->push_cb(nv, buf->bo, buf->domain, buf->offset, buf->base.width0,
+      nv->push_cb(nv, buf,
                   base, size / 4, (const uint32_t *)data);
    else
       nv->push_data(nv, buf->bo, buf->offset + base, buf->domain, size, data);
@@ -618,10 +620,7 @@ nouveau_buffer_transfer_inline_write(struct pipe_context *pipe,
        nv->push_cb &&
        !((box->x | box->width) & 3) &&
        box->width < (1 << 12)) {
-      struct nv04_resource *buf = nv04_resource(resource);
-      nv->push_cb(nv,
-                  buf->bo, buf->domain, buf->offset, buf->base.width0,
-                  box->x, box->width / 4, data);
+      nv->push_cb(nv, nv04_resource(resource), box->x, box->width / 4, data);
    } else {
       u_default_transfer_inline_write(pipe,resource,level,usage,box,data,stride,layer_stride);
    }
diff --git a/src/gallium/drivers/nouveau/nouveau_buffer.h b/src/gallium/drivers/nouveau/nouveau_buffer.h
index f881adc..41890d4 100644
--- a/src/gallium/drivers/nouveau/nouveau_buffer.h
+++ b/src/gallium/drivers/nouveau/nouveau_buffer.h
@@ -41,6 +41,8 @@ struct nv04_resource {
    uint8_t status;
    uint8_t domain;
 
+   int8_t cb_slot; /* for nv50 */
+
    struct nouveau_fence *fence;
    struct nouveau_fence *fence_wr;
 
diff --git a/src/gallium/drivers/nouveau/nouveau_context.h b/src/gallium/drivers/nouveau/nouveau_context.h
index 14608d3..70e6b01 100644
--- a/src/gallium/drivers/nouveau/nouveau_context.h
+++ b/src/gallium/drivers/nouveau/nouveau_context.h
@@ -6,6 +6,8 @@
 
 #define NOUVEAU_MAX_SCRATCH_BUFS 4
 
+struct nv04_resource;
+
 struct nouveau_context {
    struct pipe_context pipe;
    struct nouveau_screen *screen;
@@ -21,11 +23,9 @@ struct nouveau_context {
    void (*push_data)(struct nouveau_context *,
                      struct nouveau_bo *dst, unsigned, unsigned,
                      unsigned, const void *);
-   /* base, size refer to the whole constant buffer */
    void (*push_cb)(struct nouveau_context *,
-                   struct nouveau_bo *, unsigned domain,
-                   unsigned base, unsigned size,
-                   unsigned offset, unsigned words, const uint32_t *);
+                   struct nv04_resource *, unsigned offset, unsigned words,
+                   const uint32_t *);
 
    /* @return: @ref reduced by nr of references found in context */
    int (*invalidate_resource_storage)(struct nouveau_context *,
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_context.h b/src/gallium/drivers/nouveau/nv50/nv50_context.h
index e4f3831..7f7e36c 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_context.h
+++ b/src/gallium/drivers/nouveau/nv50/nv50_context.h
@@ -293,9 +293,8 @@ nv50_m2mf_copy_linear(struct nouveau_context *pipe,
                       unsigned size);
 void
 nv50_cb_push(struct nouveau_context *nv,
-             struct nouveau_bo *bo, unsigned domain,
-             unsigned base, unsigned size,
-             unsigned offset, unsigned words, const uint32_t *data);
+             struct nv04_resource *, unsigned offset, unsigned words,
+             const uint32_t *data);
 
 /* nv50_vbo.c */
 void nv50_draw_vbo(struct pipe_context *, const struct pipe_draw_info *);
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_shader_state.c b/src/gallium/drivers/nouveau/nv50/nv50_shader_state.c
index 0a54bdd..27545a2 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_shader_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_shader_state.c
@@ -90,11 +90,14 @@ nv50_constbufs_validate(struct nv50_context *nv50)
 
                assert(nouveau_resource_mapped_by_gpu(&res->base));
 
+               if (!nv50->constbuf[s][i].offset)
+                  res->cb_slot = b;
+
                BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
                PUSH_DATAh(push, res->address + nv50->constbuf[s][i].offset);
                PUSH_DATA (push, res->address + nv50->constbuf[s][i].offset);
                PUSH_DATA (push, (b << 16) |
-                          (nv50->constbuf[s][i].size & 0xffff));
+                          (align(nv50->constbuf[s][i].size, 0x100) & 0xffff));
                BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
                PUSH_DATA (push, (b << 12) | (i << 8) | p | 1);
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 946e752..57344b3 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -800,8 +800,10 @@ nv50_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
    if (nv50->constbuf[s][i].user)
       nv50->constbuf[s][i].u.buf = NULL;
    else
-   if (nv50->constbuf[s][i].u.buf)
+   if (nv50->constbuf[s][i].u.buf) {
+      nv04_resource(nv50->constbuf[s][i].u.buf)->cb_slot = -1;
       nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_CB(s, i));
+   }
 
    pipe_resource_reference(&nv50->constbuf[s][i].u.buf, res);
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_transfer.c b/src/gallium/drivers/nouveau/nv50/nv50_transfer.c
index 96b2e42..21e3fa7 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_transfer.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_transfer.c
@@ -376,33 +376,32 @@ nv50_miptree_transfer_unmap(struct pipe_context *pctx,
 
 void
 nv50_cb_push(struct nouveau_context *nv,
-             struct nouveau_bo *bo, unsigned domain,
-             unsigned base, unsigned size,
-             unsigned offset, unsigned words, const uint32_t *data)
+             struct nv04_resource *res, unsigned offset, unsigned words,
+             const uint32_t *data)
 {
    struct nouveau_pushbuf *push = nv->pushbuf;
-   struct nouveau_bufctx *bctx = nv50_context(&nv->pipe)->bufctx;
+   int8_t slot = res->cb_slot;
 
-   assert(!(offset & 3));
-   size = align(size, 0x100);
+   if (slot < 0) {
+      slot = NV50_CB_TMP;
 
-   nouveau_bufctx_refn(bctx, 0, bo, NOUVEAU_BO_WR | domain);
-   nouveau_pushbuf_bufctx(push, bctx);
-   nouveau_pushbuf_validate(push);
+      BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
+      PUSH_DATAh(push, res->address);
+      PUSH_DATA (push, res->address);
+      PUSH_DATA (push, (slot << 16) |
+                 (align(res->base.width0, 0x100) & 0xffff));
+   }
 
    while (words) {
-      unsigned nr;
+      unsigned nr = MIN2(words, NV04_PFIFO_MAX_PACKET_LEN);
 
-      nr = PUSH_AVAIL(push);
-      nr = MIN2(nr - 7, words);
-      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN - 1);
+      PUSH_SPACE(push, 16);
+      PUSH_REFN (push, res->bo, NOUVEAU_BO_WR | res->domain);
+
+      nr = MIN2(nr, PUSH_AVAIL(push) - 3);
 
-      BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
-      PUSH_DATAh(push, bo->offset + base);
-      PUSH_DATA (push, bo->offset + base);
-      PUSH_DATA (push, (NV50_CB_TMP << 16) | (size & 0xffff));
       BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
-      PUSH_DATA (push, (offset << 6) | NV50_CB_TMP);
+      PUSH_DATA (push, (offset << 6) | slot);
       BEGIN_NI04(push, NV50_3D(CB_DATA(0)), nr);
       PUSH_DATAp(push, data, nr);
 
@@ -410,6 +409,4 @@ nv50_cb_push(struct nouveau_context *nv,
       data += nr;
       offset += nr * 4;
    }
-
-   nouveau_bufctx_reset(bctx, 0);
 }
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
index a1e2d2f..4bece01 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
@@ -318,9 +318,8 @@ nve4_p2mf_push_linear(struct nouveau_context *nv,
                       unsigned size, const void *data);
 void
 nvc0_cb_push(struct nouveau_context *,
-             struct nouveau_bo *bo, unsigned domain,
-             unsigned base, unsigned size,
-             unsigned offset, unsigned words, const uint32_t *data);
+             struct nv04_resource *, unsigned offset, unsigned words,
+             const uint32_t *data);
 
 /* nvc0_vbo.c */
 void nvc0_draw_vbo(struct pipe_context *, const struct pipe_draw_info *);
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
index 6c6afee..38d492f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state_validate.c
@@ -529,23 +529,46 @@ nvc0_constbufs_validate(struct nvc0_context *nvc0)
             struct nouveau_bo *bo = nvc0->screen->uniform_bo;
             const unsigned base = s << 16;
             const unsigned size = nvc0->constbuf[s][0].size;
+            unsigned bind = align(size, 0x100);
+
             assert(i == 0); /* we really only want OpenGL uniforms here */
             assert(nvc0->constbuf[s][0].u.data);
 
-            if (nvc0->state.uniform_buffer_bound[s] < size) {
-               nvc0->state.uniform_buffer_bound[s] = align(size, 0x100);
+            bind = MAX2(bind, nvc0->state.uniform_buffer_bound[s]);
 
-               BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
-               PUSH_DATA (push, nvc0->state.uniform_buffer_bound[s]);
-               PUSH_DATAh(push, bo->offset + base);
-               PUSH_DATA (push, bo->offset + base);
+            BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
+            PUSH_DATA (push, bind);
+            PUSH_DATAh(push, bo->offset + base);
+            PUSH_DATA (push, bo->offset + base);
+            if (nvc0->state.uniform_buffer_bound[s] < bind) {
+               nvc0->state.uniform_buffer_bound[s] = bind;
                BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
                PUSH_DATA (push, (0 << 4) | 1);
             }
-            nvc0_cb_push(&nvc0->base, bo, NOUVEAU_BO_VRAM,
-                         base, nvc0->state.uniform_buffer_bound[s],
-                         0, (size + 3) / 4,
-                         nvc0->constbuf[s][0].u.data);
+            /* upload */
+            {
+               const uint32_t *data = nvc0->constbuf[s][0].u.data;
+               unsigned pos = 0;
+               unsigned words = (size + 3) / 4;
+
+               while (words) {
+                  unsigned nr = MIN2(words, NV04_PFIFO_MAX_PACKET_LEN - 1);
+
+                  PUSH_SPACE(push, 16);
+                  PUSH_REFN (push, bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM);
+                  assert(PUSH_AVAIL(push) > 2);
+
+                  nr = MIN2(nr, PUSH_AVAIL(push) - 2);
+
+                  BEGIN_1IC0(push, NVC0_3D(CB_POS), nr + 1);
+                  PUSH_DATA (push, pos);
+                  PUSH_DATAp(push, data, nr);
+
+                  words -= nr;
+                  pos += nr * 4;
+                  data += nr;
+               }
+            }
          } else {
             struct nv04_resource *res =
                nv04_resource(nvc0->constbuf[s][i].u.buf);
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c b/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c
index 4d4114a..1e67c8a 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c
@@ -509,30 +509,28 @@ nvc0_miptree_transfer_unmap(struct pipe_context *pctx,
 /* This happens rather often with DTD9/st. */
 void
 nvc0_cb_push(struct nouveau_context *nv,
-             struct nouveau_bo *bo, unsigned domain,
-             unsigned base, unsigned size,
-             unsigned offset, unsigned words, const uint32_t *data)
+             struct nv04_resource *res, unsigned offset, unsigned words,
+             const uint32_t *data)
 {
    struct nouveau_pushbuf *push = nv->pushbuf;
 
    NOUVEAU_DRV_STAT(nv->screen, constbuf_upload_count, 1);
    NOUVEAU_DRV_STAT(nv->screen, constbuf_upload_bytes, words * 4);
 
-   assert(!(offset & 3));
-   size = align(size, 0x100);
-
    BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
-   PUSH_DATA (push, size);
-   PUSH_DATAh(push, bo->offset + base);
-   PUSH_DATA (push, bo->offset + base);
+   PUSH_DATA (push, align(res->base.width0, 0x100));
+   PUSH_DATAh(push, res->address);
+   PUSH_DATA (push, res->address);
 
    while (words) {
-      unsigned nr = PUSH_AVAIL(push);
-      nr = MIN2(nr, words);
-      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN - 1);
+      unsigned nr = MIN2(words, NV04_PFIFO_MAX_PACKET_LEN - 1);
+
+      PUSH_SPACE(push, 16);
+      PUSH_REFN (push, res->bo, NOUVEAU_BO_WR | res->domain);
+      assert(PUSH_AVAIL(push) > 2);
+
+      nr = MIN2(nr, PUSH_AVAIL(push) - 2);
 
-      PUSH_SPACE(push, nr + 2);
-      PUSH_REFN (push, bo, NOUVEAU_BO_WR | domain);
       BEGIN_1IC0(push, NVC0_3D(CB_POS), nr + 1);
       PUSH_DATA (push, offset);
       PUSH_DATAp(push, data, nr);
-- 
2.1.3

